apiVersion: postgresql.cnpg.io/v1
kind: Cluster
metadata:
  name: {{ .Values.cnpg.cluster.metadata.name }}
  namespace: {{ .Values.cnpg.cluster.metadata.namespace }}
spec:
  instances: {{ .Values.cnpg.cluster.spec.instances }}
  minSyncReplicas: {{ .Values.cnpg.cluster.spec.minSyncReplicas }}
  maxSyncReplicas: {{ .Values.cnpg.cluster.spec.maxSyncReplicas }}
  replicationSlots:
    highAvailability:
      enabled: true
  # imageName: default
  monitoring:
    enablePodMonitor: true
  postgresql:
    pg_hba:
    - host all all all password
    parameters:
      max_connections: "100"
      superuser_reserved_connections: "3"
      shared_buffers: "256MB"
      timezone: "Europe/Warsaw"
  resources:
    requests:
      memory: "512Mi"
      cpu: 500m
    limits:
      memory: "512Mi"
      cpu: 500m
  {{- if .Values.global.create.enabled }}
  bootstrap:
    initdb:
      database: {{ .Values.cnpg.cluster.metadata.name }}
      owner: {{ .Values.global.users.pgAppUser }}
      secret:
        name: postgresql-app-{{ .Values.cnpg.cluster.metadata.name }}
      localeCollate: 'pl_PL.utf8'
      localeCType: 'pl_PL.utf8'
      dataChecksums: false
  {{- end }}
  {{- if .Values.global.import.enabled }}
  externalClusters:
  - name: source-cluster
    connectionParameters:
      host: "{{ .Values.global.import.sourceServiceName }}.{{ .Values.global.import.sourceNamespace }}.svc.cluster.local"
      user: {{ .Values.global.import.sourcePgAppUser }}
      dbname: {{ .Values.global.import.sourceName }}
    password:
      name: postgresql-import-{{ .Values.global.import.sourceName }}
      key: password
  bootstrap:
    initdb:
      database: {{ .Values.global.import.sourceName }}
      owner: {{ .Values.global.users.pgAppUser }}
      import:
        type: microservice
        databases:
        - {{ .Values.global.import.sourceName }}
        source:
          externalCluster: source-cluster
  {{- end }}
  {{- if and .Values.global.recovery.enabled .Values.global.backup.enabled }}
  externalClusters:
  - name: {{ .Values.global.recovery.serverName }}
    barmanObjectStore:
      destinationPath: "s3://{{ .Values.global.backup.s3bucket }}/{{ .Values.cnpg.cluster.metadata.namespace }}/postgresql/"
      endpointCA:
        name: "postgresql-s3-ca"
        key: "ca-bundle.crt"
      endpointURL: {{ .Values.global.backup.s3url }}
      s3Credentials:
        accessKeyId:
          name: postgresql-s3-{{ .Values.cnpg.cluster.metadata.name }}
          key: AWS_ACCESS_KEY_ID
        secretAccessKey:
          name: postgresql-s3-{{ .Values.cnpg.cluster.metadata.name }}
          key: AWS_SECRET_ACCESS_KEY
  bootstrap:
    recovery:
      source: {{ .Values.global.recovery.serverName }}
      owner: ${PG_APP_USERNAME}
      secret:
        name: postgresql-app-{{ .Values.cnpg.cluster.metadata.name }}
    {{- if .Values.global.recovery.pitr.enabled }}
    recoveryTarget:
        targetTime: {{ .Values.global.recovery.pitr.datetime }}
    {{- end }}
  {{- end }}
  managed:
    roles:
    - name: {{ .Values.global.users.pgAppUser }}
      comment: user
      createdb: false
      createrole: true
      replication: true
      login: true
      superuser: false
      passwordSecret:
        name: postgresql-app-{{ .Values.cnpg.cluster.metadata.name }}
    - name: {{ .Values.global.users.pgAdmUser }}
      comment: admin
      createdb: true
      createrole: true
      replication: true
      login: true
      superuser: true
      passwordSecret:
        name: postgresql-superuser-{{ .Values.cnpg.cluster.metadata.name }}
  storage:
    storageClass: {{ .Values.cnpg.cluster.spec.storage.storageClass }}
    size: {{ .Values.cnpg.cluster.spec.storage.size }}
    resizeInUseVolumes: True
  walStorage:
    size: 1Gi
    resizeInUseVolumes: True
  {{- if .Values.global.backup.enabled }}
  backup:
    {{- if or .Values.global.create.enabled .Values.global.import.enabled }}
    target: "prefer-standby"
    {{- end }}
    retentionPolicy: "3d"
    barmanObjectStore:
      destinationPath: "s3://{{ .Values.global.backup.s3bucket }}/{{ .Values.cnpg.cluster.metadata.namespace }}/postgresql/"
      endpointCA:
        name: "postgresql-s3-ca"
        key: "ca-bundle.crt"
      endpointURL: {{ .Values.global.backup.s3url }}
      {{- if .Values.global.recovery.enabled }}
      serverName: "{{ .Values.cnpg.cluster.metadata.name }}-{{ .Values.global.recovery.nameSuffix }}"
      {{- end }}
      s3Credentials:
        accessKeyId:
          name: postgresql-s3-{{ .Values.cnpg.cluster.metadata.name }}
          key: AWS_ACCESS_KEY_ID
        secretAccessKey:
          name: postgresql-s3-{{ .Values.cnpg.cluster.metadata.name }}
          key: AWS_SECRET_ACCESS_KEY
      wal:
        compression: gzip
        maxParallel: 1
      data:
        compression: gzip
        immediateCheckpoint: true
        jobs: 2
  {{- end }}